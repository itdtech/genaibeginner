<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>高度なプロンプトの作成 - GenAI新手入门</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u9ad8\u5ea6\u306a\u30d7\u30ed\u30f3\u30d7\u30c8\u306e\u4f5c\u6210";
        var mkdocs_page_input_path = "05-advanced-prompts\\translations\\ja-jp\\README.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> GenAI新手入门
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../00-course-setup/translations/cn/">课程介绍和学习环境设置</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../01-introduction-to-genai/translations/cn/">第一章：生成式人工智能和 LLMs 介绍</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../02-exploring-and-comparing-different-llms/translations/cn/">第二章：探索和比较不同的 LLMs</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../03-using-generative-ai-responsibly/translations/cn/">第三章：负责任地使用生成式人工智能</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../04-prompt-engineering-fundamentals/translations/cn/">第四章：提示工程基础</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../cn/">第五章：创建高级的提示工程技巧</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../06-text-generation-apps/translations/cn/">第六章：创建文本生成应用</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../07-building-chat-applications/translations/cn/">第七章：创建聊天应用</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../08-building-search-applications/translations/cn/">第八章：创建搜索应用</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../09-building-image-applications/translations/cn/">第九章：创建图像应用</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../10-building-low-code-ai-applications/translations/cn/">第十章：创建低代码AI应用</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../11-integrating-with-function-calling/translations/cn/">第十一章：集成函数调用</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../12-designing-ux-for-ai-applications/translations/cn/">第十二章：为人工智能应用程序设计用户体验</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../13-securing-ai-applications/translations/cn/">第十三章：保护AI应用程序</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../14-the-generative-ai-application-lifecycle/translations/cn/">第十四章：生成式AI应用生命周期</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../15-rag-and-vector-databases/translations/cn/">第十五章：检索增强生成和向量数据库</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../16-open-source-models/translations/tw/">第十六章：开源模型</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../17-ai-agents/translations/tw/">第十七章：AI Agent</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../18-fine-tuning/translations/tw/">第十八章：微调</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../19-slm/">第十九章：SLM模型</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../20-mistral/">第二十章：Mistral的模型</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../21-meta/">第二十一章：Meta的模型</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">GenAI新手入门</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">高度なプロンプトの作成</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">高度なプロンプトの作成</h1>
<p><a href="https://aka.ms/gen-ai-lesson5-gh?WT.mc_id=academic-105485-koreyst"><img alt="高度なプロンプトの作成" src="../../images/05-lesson-banner.png?WT.mc_id=academic-105485-yoterada" /></a></p>
<p>前章までの学習内容をいくつかおさらいしましょう。</p>
<blockquote>
<p>「<em>プロンプト・エンジニアリング</em>」は、より意味のある指示やコンテキスト（文脈）を提供し、「<strong>適切な回答の提供に向けてモデルを導く</strong>」プロセスです。</p>
</blockquote>
<p>また、プロンプトを作成するには 2 つの段階があります。
一つ目は関連する「<em>コンテキスト（文脈）を作成</em>」する手法で、二つ目は「<em>最適化</em>」つまりプロンプトを徐々に改善する手法です。</p>
<p>これまで、プロンプトの書き方に関連する基本的な内容について学んできましたが、さらに深く掘り下げる必要があります。この章では、さまざまなプロンプトを試し、特定のプロンプトが別のプロンプトよりも優れている理由を理解します。任意の LLM に適用できる、いくつかの基本的な手法に従ってプロンプトを作成する方法について学びます。</p>
<h2 id="_2">はじめに</h2>
<p>このレッスンでは、下記の内容について説明します。</p>
<ul>
<li>プロンプトに、さまざまな手法を適用し、プロンプト・エンジニアリングの知識の幅を広げます</li>
<li>出力を変化させるようなプロンプトを作成します</li>
</ul>
<h2 id="_3">学習目標</h2>
<p>このレッスンを修了すると、下記を理解できます：</p>
<ul>
<li>結果を改善するプロンプト・エンジニアリング手法を学ぶ</li>
<li>多様な、あるいは決定的なプロンプトを作成する</li>
</ul>
<h2 id="_4">プロンプト・エンジニアリング</h2>
<p>プロンプト・エンジニアリングは、期待する結果を生み出すためのプロンプトを作成するプロセスです。単にテキスト・プロンプトを書くだけではありません。プロンプト・エンジニアリングはエンジニアリング分野ではなく、期待する結果を得るために適用できる一連のテクニックです。</p>
<h3 id="_5">プロンプトの例</h3>
<p>次の基本的なプロンプトを見てみましょう。</p>
<blockquote>
<p>地理に関する質問を 10 問作成してください</p>
</blockquote>
<p>このプロンプトの中では、実際には一連のさまざまなプロンプトのテクニックを適用しています。</p>
<p>詳しく見ていきましょう。</p>
<ul>
<li><strong>コンテキスト :</strong> 「地理」に関する質問を指定しています。</li>
<li><strong>出力を制限 :</strong> 作成される質問の数は 10 個以下になります</li>
</ul>
<h3 id="_6">単純なプロンプトの制限</h3>
<p>期待する結果が得られる場合と得られない場合があります。地理は幅広いテーマであり、幅広いテーマは以下の理由により期待する結果が得られない場合があります。</p>
<ul>
<li><strong>大きな話題 :</strong> 国、首都、川などのような話題は大きく、どのような回答結果が得られるか予想できません。</li>
<li><strong>フォーマット :</strong> 質問を特定の方法で書式設定したい場合はどうすればよいでしょうか。</li>
</ul>
<p>ご覧のとおり、プロンプトを作成する際には考慮すべき点がたくさんあります。</p>
<p>ここまでは、簡単なプロンプトの例を見てきましたが、生成 AI は、さまざまな役割や業界の人々を支援するために、より多くの作業ができます。次に、いくつかの基本的なテクニックを確認してみましょう。</p>
<h3 id="_7">プロンプトのテクニック</h3>
<p>まずプロンプトは、大規模言語モデル (LLM) の登場で、「<em>新たに出てきたテクニック</em>」で、これはモデルに組み込まれている機能ではなく、モデルを使うために使用するものだとご理解ください。</p>
<p>LLM のプロンプトで利用可能な、基本的なテクニックがいくつかあります。それらを確認してみましょう。</p>
<ul>
<li><strong>Few shot prompting</strong>：プロンプトの最も基本的な形式で、いくつかの例 (質問例と回答例) を含む一つのプロンプトです。</li>
<li><strong>Chain-of-thought</strong>：このプロンプトは、問題を段階に分解し LLM に指示を与えます。</li>
<li><strong>Generated knowledge</strong>：プロンプトの応答を改善するため、事実や知識をプロンプトに追加で提供します。</li>
<li><strong>Least to most</strong>：Chain-of-thought(思考の連鎖)と同様に、この手法は問題を一連のステップに分解し、それらのステップを順番に実行するように指示します。</li>
<li><strong>Self-refine</strong>：この手法は、LLM からの出力結果を LLM 自ら再評価させ、評価結果に基づいて LLM に改善要求を行います。</li>
<li><strong>Maieutic prompting</strong>：これは、LLM の回答が正しいか確認するため、回答の各部分を説明するように求めます。これは自己改善の一種です。</li>
</ul>
<h3 id="few-shot-prompting">Few-shot prompting</h3>
<p>このプロンプトはとても簡単で、一つのプロンプトといくつかの例から構成します。
この手法は、LLM について学び始めたときに最初に使用すると良い手法です。次に例を示します。</p>
<ul>
<li>プロンプト: 「代数とは何ですか？」</li>
<li>回答: 「数学の一分野で、数の代わりに文字を用いて方程式の解法などを研究する学問です。」</li>
</ul>
<blockquote>
<p>[!NOTE]
訳者追記<br />
実際には上記の例は Few-shot ではなく One Shot プロンプトになっています。Few Shot プロンプトは、複数の例を含むプロンプトです。</p>
</blockquote>
<h3 id="chain-of-thought">Chain-of-thought</h3>
<p>Chain-of-thought (思考の連鎖) は、非常に興味深い手法で、一つの問題をいくつか複数の段階に分けて、LLM の回答を誘導する手法です。LLM が、何をどうやって処理を行うべきか理解できるように指示する手法です。次の例を考えてみてください。Chain-of-thought を用いた場合と用いない場合の両方の例をご覧ください。まずは、Chain-of-thought を用いない例を見てみましょう。</p>
<pre><code>- プロンプト: 「アリスはリンゴを 5 個持っていて、3 個を捨て、2 個をボブに渡し、ボブは 1 個を返します。アリスはリンゴを何個持っていますか？」
- 回答: 5
</code></pre>
<p>LLM は 5 と答えますが、これは不正解です。正しい答えはリンゴ 1 個で、計算式は (5 -3 -2 + 1 = 1) になります。</p>
<p>では、どうやって LLM がこれを正しく計算できるように伝えられるのでしょうか？</p>
<p>次に、Chain-of-thought を試してみましょう。Chain-of-thought を適用するためには：</p>
<ol>
<li>LLM に類似の例を示す。</li>
<li>計算式と、それを正しく計算する方法を示す。</li>
<li>元のプロンプトを提供する。</li>
</ol>
<p>という手順を踏みます。以下にその方法を示します。</p>
<pre><code>- プロンプト: 「リサはリンゴを7個持っていて、1個を捨て、4個をバートに渡し、バートは1個を返します。計算は次の通り：
  7 - 1 = 6
  6 - 4 = 2
  2 + 1 = 3
アリスはリンゴを 5 個持っていて、3 個を捨て、2 個をボブに渡し、ボブは 1 個を返します。アリスはリンゴを何個持っていますか？」
- 回答: 1
</code></pre>
<p>最初に類似した計算問題の計算順序や式を記述した、少し長いプロンプトを作成します。次に、本当に聞きたい内容を記述し送信します。すると正しい答え 1 が得られています。</p>
<p>ご覧の通り、Chain-of-thought (思考の連鎖) は非常に強力な手法です。</p>
<blockquote>
<p>[!TIP]
訳者追記<br />
Chain-of-thought を使うと解ける問題もありますが、なるべく LLM にロジカルな処理をさせないほうがいいかもしれません。</p>
</blockquote>
<h3 id="generated-knowledge">Generated knowledge</h3>
<p>企業環境で LLM を使用する際、Generated knowledge (生成された知識) は、プロンプトを作成する際に最も頻繁に使用する手法の一つです。Generated knowledge は、プロンプトに、会社のデータを追加する手法です。これにより、LLM が会社のデータを使用して、より正確な回答を生成できるようになります。</p>
<p>例えば、保険業界であれば、プロンプトは以下のようになります。</p>
<pre><code class="language-text">{{company}}: {{company_name}}
{{products}}:
{{products_list}}
以下の予算と要件を考慮し、保険を提案してください:
予算: {{budget}}
要件: {{requirements}}
</code></pre>
<p>上記は、テンプレートを使用してプロンプトをどのように作成するかを示しています。テンプレートには、<code>{{variable}}</code>という形式で表現する変数がいくつかあり、これらは会社の API から取得した実際の値に置き換えます。</p>
<p>以下は、変数を自社の情報に置き換えた後のプロンプト例です。</p>
<pre><code class="language-text">保険会社: ACME保険
保険商品（月額料金）:
- 自動車保険, 安価, 500ドル
- 自動車保険, 高価, 1100ドル
- 家財保険, 安価, 600ドル
- 家財保険, 高価, 1200ドル
- 生命保険, 安価, 100ドル

以下の予算と要件を考慮した上で、保険を提案してください:
予算: $1000
要件: 自動車保険, 家財保険
</code></pre>
<p>このプロンプトを LLM（Large Language Model）を実行すると、以下のような回答が得られます。</p>
<pre><code class="language-output">生命保険も含めて

予算と要件を考慮した上で、ACME保険から以下の保険パッケージを提案します:
- 自動車保険, 安価, 500ドル
- 家財保険, 安価, 600ドル
- 生命保険, 安価, 100ドル
合計費用: $1,200ドル
</code></pre>
<p>結果は、生命保険も提案されましたが、これは本来求めていない結果です。そして、プロンプトの最適化が必要だというのを示しています。プロンプトで何を許可するのかを、より明確にする必要があります。試行錯誤を繰り返した結果、以下のようなプロンプトにたどり着きました。</p>
<pre><code class="language-text">保険会社: ACME保険
保険商品（月額料金）:
- 種類: 自動車保険, 安価, 費用: 500ドル
- 種類: 自動車保険, 高価, 費用: 1100ドル
- 種類: 家財保険, 安価, 費用: 600ドル
- 種類: 家財保険, 高価, 費用: 1200ドル
- 種類: 生命保険, 安価, 費用: 100ドル

以下の予算と要件を考慮した上で、保険を提案してください:
予算: $1000 選択を以下の種類に限定: 自動車保険, 家財保険
</code></pre>
<p>「種類」と「費用」を追加し、「限定」というキーワードを使用し、LLM が何を求めているかを理解するのに役立ちます。</p>
<p>これにより、以下のような回答が得られました。</p>
<pre><code class="language-output">予算と要件を考慮した上で、月額500ドルの自動車保険（安価）を提案します。
</code></pre>
<p>この例から、Generated knowledge という手法を使用しても、期待する結果を得るためには、多くの場合でプロンプトの最適化が必要だとわかります。</p>
<h3 id="least-to-most">Least-to-most</h3>
<p>「Least-to-most (最小から最大) プロンプト」は、大きな問題を小さな問題に分割する手法です。これにより、LLM（Language Model）が大きな問題をどのように「解決」するかをガイドするのに役立ちます。良い例としては、データサイエンスがあります。LLM に以下のように問題を分割するように依頼できます。</p>
<blockquote>
<p>プロンプト: 5 つのステップで、データサイエンスを実行する方法は何ですか？</p>
</blockquote>
<p>AI アシスタントは以下のように回答します。</p>
<ol>
<li>データを収集する</li>
<li>データをクリーニングする</li>
<li>データを分析する</li>
<li>データをプロットする</li>
<li>データを提示する</li>
</ol>
<blockquote>
<p>[!TIP]
訳者追記<br />
上記の説明に加え、Least-to-most に関して追加で説明します。Chain of thought と同様に、Least-to-most は問題を一連のステップに分解し、それらのステップを順番に実行するように指示します。<br />
Chain of thought の場合は、問題の解き方をプロンプト内で具体的に指示するために、仮に解き方で記載した手順よりも難しい問題が与えられた場合は、時間を要するかもしくは回答できません。<br />
一方で、Least-to-most は、複雑な問題をより簡単なサブ問題に分解し、それらを順番に解いていきます。サブ問題を解く際には、前に解いたサブ問題の答えを利用します。<br />
たとえば、難しい問題を解くために、最初にこの問題の解き方を教えてくださいという、最小の簡単な質問をします。その結果、AI はまず、その問題の解き方を考えて教えてくれます。この問題の解き方の情報を会話履歴に含めたままで、次に、オリジナルの問題をもう一度問い合わせします。すると、会話履歴に含まれる、解き方の情報を使って、オリジナルの問題を解き回答できます。そのため、Chain of thought よりも、より難しい問題を解けるようになります。<br />
　解き方</p>
<ol>
<li>複雑な問題を一連の単純なサブ問題に分解する</li>
<li>サブ質問のそれぞれを、前の回答を元に解く
   参考情報： <a href="https://cobusgreyling.medium.com/least-to-most-prompting-b37ed2e19859?WT.mc_id=academic-105485-yoterada">1. Least to Most Prompting</a>, <a href="https://arxiv.org/pdf/2205.10625.pdf?WT.mc_id=academic-105485-yoterada">2. LEAST-TO-MOST PROMPTING ENABLES COMPLEX REASONING IN LARGE LANGUAGE MODELS (Original Paper)</a></li>
</ol>
</blockquote>
<h3 id="self-refine-critique-the-results">Self-refine, critique the results</h3>
<p>生成 AI や LLM を使用する際、その出力をそのまま信じてはいけません。必ず確認が必要です。なぜなら、LLM は何が正しいかではなく、次に出てくる可能性が最も高いものを提示しているだけだからです。そのため、LLM に自己評価を求め、それによって自己改善するという手法が有効です。</p>
<p>この手法は以下の手順で行います：</p>
<ol>
<li>最初に LLM に問題解決を求める</li>
<li>LLM が回答する</li>
<li>その回答を評価し、AI に改善を求める</li>
<li>LLM が再度回答し、今度は評価を考慮して自身が考えた解決策を提案する</li>
</ol>
<p>このプロセスは何度でも繰り返しができます。</p>
<p>以下にこの手法を使用した例を示します：</p>
<blockquote>
<p>プロンプト: "製品と顧客を持つ　 Python Web API 　を作成してください"</p>
</blockquote>
<p>AI の回答:</p>
<pre><code class="language-python">import flask
app = Flask(__name__)

@app.route('/products')
def products():
    return 'Products'

@app.route('/customers')
def customers():
    return 'Customers'
</code></pre>
<blockquote>
<p>プロンプト: "上記のコードの改善点を 3 つ提案してください"</p>
</blockquote>
<p>AI の回答:</p>
<pre><code class="language-text">もちろんです、コードを改善するための3つの提案をします：

正しいモジュールをインポートする：最初の行は flask ではなく Flask をインポートするべきです。正しいインポート文は from flask import Flask となります。

メイン関数を追加する：ファイルを実行した際、アプリケーションを実行できるように、if __name__ == '__main__': ブロックをファイルの最後に追加します。

f-strings を使用する：ルート関数の return 文をフォーマットするために f-strings を使用します。例えば、'Products' を返す代わりに、f'This is the {request.path} page' を返すように変更できます。
</code></pre>
<pre><code class="language-python">from flask import Flask, request

app = Flask(__name__)

@app.route('/products')
def products():
    return f'This is the {request.path} page'

@app.route('/customers')
def customers():
    return f'This is the {request.path} page'

if __name__ == '__main__':
    app.run()
</code></pre>
<p>上記の AI の回答を見ると、最初の回答を再評価し、最初に提案されたコードが改善されているのがわかります。</p>
<h3 id="maieutic-prompting">Maieutic prompting</h3>
<p>Maieutic プロンプトは、self-refine (自己改善) と似た手法ですが、こちらは LLM に自身で説明を求めるものです。LLM の出力における不整合を減らし、正確な回答を取得するのを目指します。そのための手順は以下のようになります。</p>
<ol>
<li>LLM に質問に答えるよう求める</li>
<li>答えの各部分について、LLM に詳しく説明させる</li>
<li>不整合がある場合、その部分は排除する</li>
</ol>
<p>これら全ての内容を検討し、回答に満足するまで 2 と 3 の手順を繰り返します。</p>
<p>以下に、例を示します。</p>
<blockquote>
<p>プロンプト: パンデミックを緩和するための危機対策を 5 つの段階でどのように作成すればよいか教えてください。</p>
</blockquote>
<p>LLM の回答:</p>
<pre><code class="language-text">1. リスクを特定する
2. 利害関係者を特定する
3. リソースを特定する
4. 行動を特定する
5. コミュニケーションチャネルを特定する
</code></pre>
<p>5 つが特定されましたが、これが正しいかどうかを確認するために、LLM に各内容を詳しく説明させてみましょう。</p>
<blockquote>
<p>プロンプト: 最初のステップを詳しく説明してください。具体的には、パンデミックにおけるリスクは何ですか？</p>
</blockquote>
<pre><code class="language-text">リスクは以下の通りです：

- 生命の喪失
- ビジネスの喪失
- 評判の喪失
- 顧客の喪失
- 従業員の喪失
</code></pre>
<p>ここで、LLM が正しいかどうかを確認するため、最初のリスクについて詳しく説明させ、それが上記の答えと一致するか確認します。</p>
<blockquote>
<p>プロンプト: パンデミックにおいて、最も大きなリスクは何でしょうか？また、その理由は何ですか？</p>
</blockquote>
<pre><code class="language-text">最も大きなリスクは生命の喪失で、それは最も重要な守るべきものです。
</code></pre>
<blockquote>
<p>パンデミックにおけるリスクの中で、最も大きな 2 つのリスクは何だと思いますか？</p>
</blockquote>
<pre><code class="language-text">最も大きな2つのリスクは、生命の喪失とビジネスの喪失です。
</code></pre>
<p>ここで、LLM 　は一貫性を保ち、「生命」と「ビジネス」を最大の 2 つのリスクとして挙げています。これにより、次のステップに進み、かなりの自信を持てます。ただし、LLM 　を盲目的に信頼するのではなく、常にその出力を検証するのが重要です。</p>
<h2 id="vary-your-output">Vary your output</h2>
<p>LLM は本質的に非確実な性質を持っているため、同じプロンプトを実行しても結果は毎回異なります。例えば、以下のプロンプトを試してみてください。</p>
<blockquote>
<p>"Python Web API のコードを生成してください"</p>
</blockquote>
<pre><code class="language-python"># 必要なモジュールをインポートする
import flask
from flask import request, jsonify

# Flaskアプリを作成する
app = flask.Flask(__name__)

# APIのルートを作成する
@app.route('/api', methods=['GET'])
def api():
    # リクエストからデータを取得する
    data = request.args

    # データを処理する
    result = process_data(data)

    # 結果をJSONとして返す
    return jsonify(result)

# データを処理する関数
def process_data(data):
    # データを何かしら処理する
    result = data + 1

    # 結果を返す
    return result

# アプリを実行する
if __name__ == '__main__':
    app.run()
</code></pre>
<p>同じプロンプトを再度実行すると、少し異なる結果が出力されます。</p>
<pre><code class="language-python"># 必要なパッケージをインポートする
import flask
from flask import request, jsonify

# Flaskアプリケーションを作成する
app = flask.Flask(__name__)
app.config[&quot;DEBUG&quot;] = True

# 本のリストを作成する
books = [
    {'id': 0,
     'title': 'A Fire Upon the Deep',
     'author': 'ヴァーナー・ヴィンジ',
     'first_sentence': 'コールドスリープ自体は夢がない。',
     'year_published': '1992'},
    {'id': 1,
     'title': 'The Ones Who Walk Away From Omelas',
     'author': 'アーシュラ・K・ル=グウィン',
     'first_sentence': '鐘の騒音がツバメを舞い上がらせ、夏の祭りが海に面した明るい塔の街オメラスにやってきた。',
     'published': '1973'},
    {'id': 2,
     'title': 'Dhalgren',
     'author': 'サミュエル・R・ディレイニ',
     'first_sentence': '秋の街に傷をつけるために',
     'published': '1975'}
]

# APIのエンドポイントを作成する
@app.route('/', methods=['GET'])
def home():
    return '''&lt;h1&gt;Books API&lt;/h1&gt;
&lt;p&gt;A prototype API for retrieving books.&lt;/p&gt;'''

# すべての本を返すエンドポイントを作成する
@app.route('/api/v1/resources/books/all', methods=['GET'])
def api_all():
    return jsonify(books)

# 単一の本を返すエンドポイントを作成する
@app.route('/api/v1/resources/books', methods=['GET'])
def api_id():
    # IDがURLの一部として提供されたか確認する
    # IDが提供された場合は、それを変数に割り当てる
    # IDが提供されていない場合は、エラーを表示する
    if 'id' in request.args:
        id = int(request.args['id'])
    else:
        return &quot;Error: No id field provided. Please specify an id.&quot;

    # 結果のための空のリストを作成する
    results = []

    # データをループして、リクエストされたIDに一致する結果を探す
    # IDは一意ですが、他のフィールドは多数の結果を返す可能性があります
    for book in books:
        if book['id'] == id:
            results.append(book)

    # Flaskのjsonify関数を使用して、Pythonの辞書のリストをJSON形式に変換する
    return jsonify(results)

app.run()
</code></pre>
<blockquote>
<p>では、このような出力のバリエーションは問題なのでしょうか？</p>
</blockquote>
<p>それは、皆様が何を実現したいかによります。特定の確実な回答を求めている場合、それは問題となります。しかし、「地理に関する任意の 3 つの質問を生成する」のように、出力のバリエーションに対して柔軟であれば問題ではありません。</p>
<h3 id="_8">温度を使用して出力を変化させる</h3>
<p>出力をより予測可能、つまりより決定論的(確実)に制限したいと考えた場合、どのようにすればよいでしょうか？</p>
<p>Temperature (温度) パラメータは 0 から 1 までの範囲で値を持っており、0 が最も決定的で、1 が最も多様性があります。デフォルト値は 0.7 です。温度を 0.1 に設定し、同じプロンプトを 2 回実行してみると以下のような結果が得られます。</p>
<blockquote>
<p>"Python Web API のコード を作成してください"</p>
</blockquote>
<pre><code class="language-python">#import necessary libraries
import flask
from flask import request, jsonify

#create an instance of the Flask class
app = flask.Flask(__name__)

#create an endpoint for the API
@app.route('/api/v1/endpoint', methods=['GET'])
def api_endpoint():
    #get the request data
    data = request.get_json()

    #process the data
    result = process_data(data)

    #return the result
    return jsonify(result)

#function to process the data
def process_data(data):
    #process the data
    result = {'result': 'success'}

    #return the result
    return result

#run the Flask app
if __name__ == '__main__':
    app.run()
</code></pre>
<p>プロンプトを再度実行すると、次の結果が得られます。</p>
<pre><code class="language-python">#import necessary libraries
import flask
from flask import request, jsonify

#create a Flask app
app = flask.Flask(__name__)

#create a route for the API
@app.route('/api', methods=['GET'])
def api_call():
    #get the data from the request
    data = request.get_json()

    #process the data
    result = process_data(data)

    #return the result
    return jsonify(result)

#define the process_data function
def process_data(data):
    #do something with the data
    result = data + 1

    #return the result
    return result

#run the app
if __name__ == '__main__':
    app.run()
</code></pre>
<p>これら 2 つの出力結果はわずかな違いしかありません。今度は逆に、温度を 0.9 に設定してみましょう。</p>
<pre><code class="language-python"># Import necessary libraries
import flask
from flask import request, jsonify

# Create a Flask app
app = flask.Flask(__name__)

# Create a route for the API
@app.route('/api', methods=['GET'])
def api_call():
    # Get the data from the request
    data = request.args

    # Process the data
    result = process_data(data)

    # Return the result
    return jsonify(result)

# Function to process the data
def process_data(data):
    # Do something with the data
    result = data + 1

    # Return the result
    return result

# Run the app
if __name__ == '__main__':
    app.run()
</code></pre>
<p>温度パラメータの値として 0.9 で 2 回目の実行:</p>
<pre><code class="language-python">import flask
from flask import request, jsonify

# create the Flask app
app = flask.Flask(__name__)
app.config['DEBUG'] = True

# create some test data
books = [
    {'id': 0, 'title': 'A Fire Upon The Deep', 'author': 'Vernor Vinge', 'first_sentence': 'The coldsleep itself was dreamless.', 'year_published': '1992'},
    {'id': 1, 'title': 'The Ones Who Walk Away From Omelas', 'author': 'Ursula K. Le Guin', 'first_sentence': 'With a clamor of bells that set the swallows soaring, the Festival of Summer came to the city Omelas, bright-towered by the sea.', 'published': '1973'},
    {'id': 2, 'title': 'Dhalgren', 'author': 'Samuel R. Delany', 'first_sentence': 'to wound the autumnal city.', 'published': '1975'}
]

# create an endpoint
@app.route('/', methods=['GET'])
def home():
    return '''&lt;h1&gt;Welcome to our book API!&lt;/h1&gt;'''

@app.route('/api/v1/resources/books
</code></pre>
<p>ご覧いただいたように、結果は非常に多様（違う内容）になります。</p>
<blockquote>
<p>なお、出力を変化させるために変更できるパラメータは他にもあります。例えば、top-k, top-p, repetition penalty, length penalty, diversity penalty などですが、これらはこのレッスンでは取り扱いません。</p>
</blockquote>
<h2 id="_9">おすすめの方法</h2>
<p>皆様が目的の結果を得るためには、様々な方法をお試しできます。プロンプトを利用する頻度が増えるほど、ご自身専用のスタイルを身に付けられるでしょう。</p>
<p>これまでに紹介したテクニックに加えて、LLM を活用する際におすすめの方法がいくつかあります。</p>
<p>以下に、そのおすすめの方法をいくつか紹介します。</p>
<ul>
<li><strong>コンテキストを明確にする</strong>：コンテキスト(文脈)は重要で、ドメインやトピックなど、具体的に指定するほど良い結果が得られます。</li>
<li><strong>出力を制限する</strong>：特定の項目数や特定の長さが必要な場合は、それを明示的に指定しましょう。</li>
<li><strong>「何を」、「どうするか」を明確にする</strong>：例えば、「Python の Web API を作成し、商品と顧客を設定し、それを 3 つのファイルに分けてください」といった、具体的な指示を出すようにしてください</li>
<li><strong>テンプレートを活用する</strong>：自社データをプロンプトに反映させたい場合も多いと思います。その際に、テンプレートを活用しましょう。テンプレートには、実際のデータに置き換えられる変数を設定できます。</li>
<li><strong>正確に記述する</strong>：スペル・ミスがあっても LLM は正しい回答を提供してくれるかもしれませんが、スペルが正確であれば、より良い回答が得られます。</li>
</ul>
<h2 id="_10">課題</h2>
<p>Flask を使用して単純な API を構築する方法を示す Python のコードを次に示します。</p>
<pre><code class="language-python">from flask import Flask, request

app = Flask(__name__)

@app.route('/')
def hello():
    name = request.args.get('name', 'World')
    return f'Hello, {name}!'

if __name__ == '__main__':
    app.run()
</code></pre>
<p>上記のコードを、GitHub Copilot や ChatGPT などの AI アシスタントを使用し、「self-refine (自己調整)」の手法を適用してコードを改善してください。</p>
<h2 id="_11">解決</h2>
<p>コードに対して適切なプロンプトを追加し、課題の解決を試みてください。</p>
<blockquote>
<p>[!TIP]
プロンプトの改善を求める際、対象となる改善項目を制限すると効果が高まります。また、アーキテクチャ、パフォーマンス、セキュリティといった特定の観点から改善を求めるアプローチも有効です。</p>
</blockquote>
<p><a href="../../python/aoai-solution.py?WT.mc_id=academic-105485-koreyst">Solution</a></p>
<h2 id="_12">知識チェック</h2>
<p>なぜ、chain-of-thought (思考の連鎖) プロンプトを使用するのでしょうか? 正解を 1 つ選択してください。</p>
<ol>
<li>LLM に問題の解決方法を教える。</li>
<li>LLM にコード内のエラーを見つけるように教える</li>
<li>LLM にさまざまな解決策を考えるように指示する</li>
</ol>
<p>答え：1：chain-of-thought (思考の連鎖) プロンプトは、LLM に回答を導き出すための一連の処理段階と、類似問題とその解決方法を提供し、問題解決方法を示します。</p>
<h2 id="challenge">🚀 Challenge</h2>
<p>課題では、self-refine (自己改善) の手法を使用しました。皆様が実際に実装したプログラムを取り上げて、それに対してどのように改善したいか考えてみてください。そして、その改善案を self-refine (自己改善)の手法を使って実際に適用してみましょう。結果は良くなりましたか？悪くなりましたか？どう思われますか?</p>
<h2 id="_13">お疲れ様でした!学習を続ける</h2>
<p>このレッスン修了後、<a href="https://aka.ms/genai-collection?WT.mc_id=academic-105485-yoterada">生成 AI 学習コレクション</a> をチェックして、Generative AI の知識をレベルアップさせましょう。</p>
<p>レッスン 6 では、プロンプト エンジニアリングの知識を応用して<a href="../../../06-text-generation-apps/translations/ja-jp/?WT.mc_id=academic-105485-yoterada">テキスト生成アプリケーションの構築</a>を行います。</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
